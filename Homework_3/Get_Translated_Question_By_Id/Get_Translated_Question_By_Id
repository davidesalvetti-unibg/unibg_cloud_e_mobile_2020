/**
 * TO BE REVIEWED
 * 
 */
var AWS = require('aws-sdk')
AWS.config.update({region: 'us-east-1'})
var translate = new AWS.Translate();


const connect_to_db = require('./db');

// GET BY QUESTION HANDLER

const questions = require('./Question');

module.exports.get_question_id = (event, context, callback) => {
    context.callbackWaitsForEmptyEventLoop = false;
    console.log('Received event:', JSON.stringify(event, null, 2));
    let body = {}
    if (event.body) {
        body = JSON.parse(event.body)
    }
    // set default
    if(!body.id) {
        callback(null, {
                    statusCode: 500,
                    headers: { 'Content-Type': 'text/plain' },
                    body: 'Could not fetch the watch next. Id is null.'
        })
    }
    
    if (!body.language) {
        body.language = 'en';
    }
    
    if (!body.doc_per_page) {
        //implement
    }
    
    if (!body.page_num) {
        //implement
    }
    
    console.log("Connect to db...")
    connect_to_db().then(() => {
        console.log('=> get questions');
        questions.find({_id: body.id}, {_id: 1, questions_obj: 1})
        .then(async (quest) => {
                console.log("We found this questions:" + quest)
                console.log("Typeof:" + typeof(quest))
                
                if (body.level)
                    filterQuestionsByLevel(quest, body.level);
                
                for (var key in quest) {
                    console.log("Object extracted" + JSON.stringify(quest[key].questions_obj))
                    for (var it in quest[key].questions_obj) {
                        console.log("What the fuck is this "+ it + " " + quest[key].questions_obj[it] + JSON.stringify(quest[key].questions_obj[it]))
                        var question_obj = quest[key].questions_obj[it]
                        for (var it in question_obj) {
                            console.log("Livello:" + question_obj[it])
                            if (it != "level")
                                await traduci(question_obj,it, body.language);
                        }
                    }
                }
                callback(null, {
                    statusCode: 200,
                    body: JSON.stringify(quest)
                })
            }
        )
        .catch(err =>
            callback(null, {
                statusCode: err.statusCode || 500,
                headers: { 'Content-Type': 'text/plain' },
                body: 'Could not fetch the questions'
            })
        );
    });
};

const filterQuestionsByLevel= async(question, level) => {
    return new Promise((resolve, reject) => {
        var deleted;
        do {
            deleted = false;
            for (let key in question) {
                console.log("Key:" + key)
                for (let it in question[key].questions_obj) {
                    console.log("it:" + it)
                    let question_obj = question[key].questions_obj[it]
                    for (let it_2 in question_obj) {
                        console.log("it_2:" + it_2 + " " + question_obj[it_2])
                        if (it_2 == "level") {
                            if (question_obj[it_2] != level) {
                                question[key].questions_obj.splice(it, 1)
                                console.log("Deleting:" + question_obj[it_2] + " " + question)
                                deleted = true;
                                break;
                            }
                        }
                    }
                    if (deleted)
                        break;
                }
                if (deleted)
                    break;
            }
        } while (deleted);
        
        resolve();
    });
}

const traduci = async (question_obj,it,language) => {
    return new Promise((resolve, reject) => {
        var translateParams = {
            SourceLanguageCode: 'en',
            TargetLanguageCode: language,
            Text: JSON.stringify(question_obj[it])
        };
        console.log("inside we have " + it + " "+ question_obj[it] + " " + JSON.stringify(question_obj[it]))
        translate.translateText(translateParams, (err, data) => {
            if (err) console.log("Erros String: " + err)
            console.log("Latest Translation: " + data.TranslatedText)
            question_obj[it] = data.TranslatedText
            //to do bisogna lavorare sul dato, in ogni lingua ci sono delle virgolette diverse che vengono aggiunte.
            // probabilmente basta eliminare sempre il primo e l'ultimo carattere
            resolve();
        })
    });
}

